#include "./HeightmapShader.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel GenerateBaseTexture
#pragma kernel RegenerateBaseTexture
#pragma kernel GenerateHeightmapTexture
#pragma kernel GenerateColorTexture


// Texture data
uint height;
uint width;

// Input
Texture2D<float4> base_texture;
Texture2D<float> height_texture;

// Output
RWTexture2D<float4> base_texture_out;
RWTexture2D<float> height_texture_out;
RWTexture2D<float4> color_texture_out;

[numthreads(1,1,1)]
void GenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{
	// ###################################
	// 	This kernel will create a texture and calculate for every pixel the
	// 	the vertex values that pixel would be at if rapped around a cube. Then
	// 	the vertex data gets normalized representing a cube sphere. 
	// ###################################

	uint x = id.x;
	uint y = id.y;
	float4 value = 0;
	
	// Depending on the y value set properties
	if(y < height / 3) {
		value.y = 0;
		value.z = 3 * ((float)y) / height;
	} else if (y < 2 * height / 3) {
		value.y = 3 * ((float)y) / height - 1;
	} else{
		value.y = 1;
		value.z = 3 * (1 - ((float)y) / height);
	}

	// Depending on the x value set properties
	if(x < width/4){
		value.x = 1;
		value.z = 4 * ((float) x) / width;
	} else if(x < width/2){
		value.x = 2 - 4 * ((float) x) / width;
	} else if(x < 3*width/4){
		value.x = 0;
		value.z = 3 - 4 * ((float) x) / width;
	} else {
		value.x = 4 * ((float) x) / width - 3;
	}

	if(x >= width/4 && x < width/2 && y >= height/3 && y < 2*height/3){
		value.z = 1;
	}
	if (x > 3 * width / 4 && y >= height/3 && y <= 2 * height / 3) {
		value.z = 0;
	}
	// Depending on the x and y value set visibility
	if (width / 4 < x && x < width / 2) value.a = 1;
	else if(height / 3 < y && y < 2* height / 3) value.a = 1;
	value.xyz = normalize(value.xyz - 0.5);
	value.xyz = (value.xyz + 1) / 2;
	base_texture_out[id.xy] = value;
}

float4 left_bottom_corner;
float4 right_bottom_corner;
float4 left_top_corner;
float4 right_top_corner;

[numthreads(1,1,1)]
void RegenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{
	float x_value = ((float) id.x) / width;
	float y_value = ((float) id.y) / height;
	float4 bottom_vec = lerp(left_bottom_corner, right_bottom_corner, x_value);
	float4 top_vec = lerp(left_top_corner, right_top_corner, x_value);
	float4 value = lerp(bottom_vec, top_vec, y_value);
	value.xyz = normalize(value.xyz - 0.5);
	value.xyz = (value.xyz + 1) / 2;
	base_texture_out[id.xy] = value;
}

[numthreads(1, 1, 1)]
void GenerateHeightmapTexture(uint3 id : SV_DispatchThreadID)
{
	height_texture_out[id.xy] = CalculateHeightValue(2*base_texture[id.xy].xyz-1, 10);
}

float4 ColorA;
float4 ColorB;

[numthreads(1, 1, 1)]
void GenerateColorTexture(uint3 id : SV_DispatchThreadID)
{
	color_texture_out[id.xy] = lerp(ColorA, ColorB, height_texture[id.xy]);
}
