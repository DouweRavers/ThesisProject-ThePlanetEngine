#pragma enable_d3d11_debug_symbols
#pragma kernel GenerateBaseTexture
#pragma kernel GenerateBiomeTexture
#pragma kernel RegenerateBaseTexture


// Texture data
uint height;
uint width;

// Input
Texture2D<float4> base_texture;
Texture2D<float4> biome_texture;
Texture2D<float> height_texture;

// Output
RWTexture2D<float4> base_texture_out;
RWTexture2D<float4> biome_texture_out;
RWTexture2D<float> height_texture_out;

[numthreads(1,1,1)]
void GenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{
	// ###################################
	// 	This kernel will create a texture and calculate for every pixel the
	// 	the vertex values that pixel would be at if rapped around a cube. Then
	// 	the vertex data gets normalized representing a cube sphere. 
	// ###################################

	uint x = id.x;
	uint y = id.y;
	float4 value = 0;
	
	// Depending on the y value set properties
	if(y < height / 3) {
		value.y = 0;
		value.z = 3 * ((float)y) / height;
	} else if (y < 2 * height / 3) {
		value.y = 3 * ((float)y) / height - 1;
	} else{
		value.y = 1;
		value.z = 3 * (1 - ((float)y) / height);
	}

	// Depending on the x value set properties
	if(x < width/4){
		value.x = 1;
		value.z = 4 * ((float) x) / width;
	} else if(x < width/2){
		value.x = 2 - 4 * ((float) x) / width;
	} else if(x < 3*width/4){
		value.x = 0;
		value.z = 3 - 4 * ((float) x) / width;
	} else {
		value.x = 4 * ((float) x) / width - 3;
	}

	if(x >= width/4 && x < width/2 && y >= height/3 && y < 2*height/3){
		value.z = 1;
	}

	// Depending on the x and y value set visibility
	if (width / 4 < x && x < width / 2) value.a = 1;
	else if(height / 3 < y && y < 2* height / 3) value.a = 1;
	value.xyz = normalize(value.xyz - 0.5);
	value.xyz = (value.xyz + 1) / 2;
	base_texture_out[id.xy] = value;
}

StructuredBuffer<float3> vonoroi_points;
int vonoroi_point_count;

[numthreads(1,1,1)]
void GenerateBiomeTexture(uint3 id : SV_DispatchThreadID)
{
	float4 value = 0.0;
	float3 pixel_vertex = base_texture[id.xy].xyz;
	if(base_texture[id.xy].a != 0){
		float minimum_dist1 = 100.0;
		float minimum_dist2 = 100.0;
		uint size = (uint) vonoroi_point_count;
		float closest1 = 0.0, closest2 = 0.0;
		for(uint i = 0; i < size; i++){
			float3 point_vertex = vonoroi_points[i];
			float3 diff = abs(pixel_vertex - point_vertex);
			float dist = diff.x + diff.y + diff.z;
			if(dist < minimum_dist1){
				minimum_dist2 = minimum_dist1;
				closest2 = closest1;
				minimum_dist1 = dist;
				closest1 = ((float)i)/size;
			} else if(dist < minimum_dist1){
				minimum_dist2 = minimum_dist1;
				closest2 = ((float)i)/size;
			}
		}
		value = float4(closest1, closest2, (minimum_dist2 - minimum_dist1) / minimum_dist2, 1);
	}
	biome_texture_out[id.xy] = value;
}


float4 left_bottom_corner;
float4 right_bottom_corner;
float4 left_top_corner;
float4 right_top_corner;


[numthreads(1,1,1)]
void RegenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{
	float x_value = ((float) id.x) / width;
	float y_value = ((float) id.y) / height;
	float4 bottom_vec = lerp(left_bottom_corner, right_bottom_corner, x_value);
	float4 top_vec = lerp(left_top_corner, right_top_corner, x_value);
	float4 value = lerp(bottom_vec, top_vec, y_value);
	value.xyz = normalize(value.xyz - 0.5);
	value.xyz = (value.xyz + 1) / 2;
	base_texture_out[id.xy] = value;
}