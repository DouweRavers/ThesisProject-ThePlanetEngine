#include "../ShaderLib/noiseSimplex.cginc"

#pragma enable_d3d11_debug_symbols
#pragma kernel GenerateHeightmapTexture
#pragma kernel GenerateHeightmapColorTexture
#pragma kernel GenerateHeightmapReflectiveTexture

// Procedural data
uint seed;
bool has_ocean;
float continent_scale;


// Texture data
uint height;
uint width;

// Input
Texture2D<float4> base_texture;
Texture2D<float> height_texture;
Texture2D<float4> gradient_texture;

// Output
RWTexture2D<float> height_texture_out;
RWTexture2D<float4> color_texture_out;


[numthreads(1, 1, 1)]
void GenerateHeightmapTexture(uint3 id : SV_DispatchThreadID)
{
    height_texture_out[id.xy] = snoise(continent_scale * base_texture[id.xy].xyz + seed);
}

[numthreads(1, 1, 1)]
void GenerateHeightmapColorTexture(uint3 id : SV_DispatchThreadID)
{
    float temp = abs(base_texture[id.xy].y) * width;
    float depth = (height_texture[id.xy] / 2 + 0.5) * height;
    float4 color = gradient_texture[float2(temp, depth)];
    if (has_ocean)
    {    
        if (height_texture[id.xy] > 0)
        {
            color = 1 - color;
            color.a = 1;
            color_texture_out[id.xy] = color;
        }
        else
        {
            color_texture_out[id.xy] = color;
        }
    }
    else
    {
        color_texture_out[id.xy] = color;
    }
}

[numthreads(1, 1, 1)]
void GenerateHeightmapReflectiveTexture(uint3 id : SV_DispatchThreadID)
{
    if (height_texture[id.xy] > 0)
    {
        color_texture_out[id.xy] = 0;
    }
    else
    {
        color_texture_out[id.xy] = 0.7;
    }
}
