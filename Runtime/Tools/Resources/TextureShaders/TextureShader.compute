#include "./HeightmapShader.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel GenerateBaseTexture
#pragma kernel GenerateSideBaseTexture
#pragma kernel RegenerateBaseTexture
#pragma kernel GenerateHeightmapTexture
#pragma kernel GenerateColorTexture

// Texture data
uint height;
uint width;

// Input
Texture2D<float4> base_texture;
Texture2D<float> height_texture;

// Output
RWTexture2D<float4> base_texture_out;
RWTexture2D<float> height_texture_out;
RWTexture2D<float4> color_texture_out;

// ###################################
// Generates a texture which holds the vertex data of the space the pixel would
// be at if it was wrapped around a unit sphere.
// ###################################

[numthreads(1,1,1)]
void GenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{


	uint x = id.x;
	uint y = id.y;
	float4 value = 0;
	float x_value = ((float)id.x) / (width - 1);
	float y_value = ((float)id.y) / (height - 1);

	// Depending on the y value set properties
	if(y < height / 3) {
		value.y = 0;
		value.z = 3 * y_value;
	} else if (y < 2 * height / 3) {
		value.y = 3 * y_value - 1;
	} else{
		value.y = 1;
		value.z = 3 * (1 - y_value);
	}

	// Depending on the x value set properties
	if(x < width/4){
		value.x = 1;
		value.z = 4 * x_value;
	} else if(x < width/2){
		value.x = 2 - 4 * x_value;
	} else if(x < 3*width/4){
		value.x = 0;
		value.z = 3 - 4 * x_value;
	} else {
		value.x = 4 * x_value - 3;
	}

	if(x >= width/4 && x < width/2 && y >= height/3 && y < 2*height/3){
		value.z = 1;
	}
	if (x > 3 * width / 4 && y >= height/3 && y <= 2 * height / 3) {
		value.z = 0;
	}
	
	value.xyz = value.xyz - 0.5;
	value.a = length(value.xyz);
	value.xyz = normalize(value.xyz);
	base_texture_out[id.xy] = value;
}

// ###################################
// Generates a texture which holds the vertex data of the space the pixel would
// be at if it was wrapped around a single side of a unit cube sphere.
// ###################################

uint side;

[numthreads(1, 1, 1)]
void GenerateSideBaseTexture(uint3 id : SV_DispatchThreadID)
{
	float4 value = 1;
	float x_value = ((float)id.x) / (width-1);
	float y_value = ((float)id.y) / (height-1);

	if (side == 0) { // FRONT
		value.x = lerp(1, 0, x_value);
		value.y = lerp(0, 1, y_value);
		value.z = 1;
	} else if (side == 1) { // BACK
		value.x = lerp(0, 1, x_value);
		value.y = lerp(0, 1, y_value);
		value.z = 0;
	} else if (side == 2) { // LEFT
		value.x = 1;
		value.y = lerp(0, 1, y_value);
		value.z = lerp(0, 1, x_value);
	} else if (side == 3) { // RIGHT
		value.x = 0;
		value.y = lerp(0, 1, y_value);
		value.z = lerp(1, 0, x_value);
	} else if (side == 4) { // TOP
		value.x = lerp(1, 0, x_value);
		value.y = 1;
		value.z = lerp(1, 0, y_value);
	} else if (side == 5) { // BOTTOM
		value.x = lerp(1, 0, x_value);
		value.y = 0;
		value.z = lerp(0, 1, y_value);
	}
	
	value.xyz = value.xyz - 0.5;
	value.a = length(value.xyz);
	value.xyz = normalize(value.xyz);
	base_texture_out[id.xy] = value;
}

// ###################################
// Generates a texture that is a zoomed in version of the textures generated by the previous two
// kernels. By defining the corners of the new texture a new texture with higher detail will be generated.
// ###################################

int2 left_bottom_corner;
int2 right_bottom_corner;
int2 left_top_corner;
int2 right_top_corner;

[numthreads(1,1,1)]
void RegenerateBaseTexture(uint3 id : SV_DispatchThreadID)
{
	float x_value = ((float) id.x) / (width-1);
	float y_value = ((float) id.y) / (height-1);
	
	float4 lb_vec = base_texture[left_bottom_corner];
	float4 rb_vec = base_texture[right_bottom_corner];
	float4 lt_vec = base_texture[left_top_corner];
	float4 rt_vec = base_texture[right_top_corner];

	float3 bottom_vec = lerp(
		lb_vec.xyz * lb_vec.a,
		rb_vec.xyz * rb_vec.a,
		x_value
	);
	
	float3 top_vec = lerp(
		lt_vec.xyz * lt_vec.a,
		rt_vec.xyz * rt_vec.a,
		x_value
	);
	float3 cube_vec = lerp(bottom_vec, top_vec, y_value);
	float4 value = float4(cube_vec, length(cube_vec));
	
	value.xyz = normalize(value.xyz);
	base_texture_out[id.xy] = value;
}

[numthreads(1, 1, 1)]
void GenerateHeightmapTexture(uint3 id : SV_DispatchThreadID)
{
    height_texture_out[id.xy] = CalculateHeightValue(base_texture[id.xy].xyz, 10);
}

float4 ColorA;
float4 ColorB;

[numthreads(1, 1, 1)]
void GenerateColorTexture(uint3 id : SV_DispatchThreadID)
{
	color_texture_out[id.xy] = lerp(ColorA, ColorB, height_texture[id.xy]);
}
