#include "../ShaderLib/ProceduralLib.cginc"

#pragma enable_d3d11_debug_symbols
#pragma kernel GenerateHeightmapColorTexture
#pragma kernel GenerateHeatmapColorTexture
#pragma kernel GenerateHumidityColorTexture
#pragma kernel GenerateBiomeColorTexture
#pragma kernel GenerateOceanColorTexture
#pragma kernel GenerateGroundColorTexture

// Procedural data
bool has_ocean;
float continent_scale;
float reflectiveness;
float solar_heat;
float height_cooling;

// Texture data
uint height;
uint width;

// Input
Texture2D<float4> base_texture;
Texture2D<float> height_texture;
Texture2D<float> heat_texture;
Texture2D<float> humidity_texture;
Texture2D<float4> gradient_ocean_texture;
Texture2D<float4> gradient_biome_texture;

// Output
RWTexture2D<float4> color_texture_out;

// Local function declarations
float4 GetOceanColor(uint3 id);

[numthreads(1, 1, 1)]
void GenerateHeightmapColorTexture(uint3 id : SV_DispatchThreadID)
{
    float height_value = height_texture[id.xy];
    if (height_value < 0 && has_ocean)
    {
        float3 vertex = base_texture[id.xy].xyz;
        float heat = CalculateHeatValue(vertex, height_value, solar_heat, height_cooling, has_ocean);
        float depth = clamp(-height_value, 0, 1);
        color_texture_out[id.xy] = gradient_ocean_texture[uint2(heat * width, depth * height)]; 
    }
    else
    {
        color_texture_out[id.xy] = (height_value + 1) / 2;
    }
}


[numthreads(1, 1, 1)]
void GenerateHeatmapColorTexture(uint3 id : SV_DispatchThreadID)
{
    float data = heat_texture[id.xy];
    float3 color;
    if (data < 0.5)
    {
        float heat = data * 2;
        color = float3(heat, heat, 1 - heat);
    }
    else
    {
        float heat = (data - 0.5) * 2;
        color = float3(1, 1 - heat, 0);
    }
    color_texture_out[id.xy] = float4(color, 1);
}


[numthreads(1, 1, 1)]
void GenerateHumidityColorTexture(uint3 id : SV_DispatchThreadID)
{
    color_texture_out[id.xy] = float4(0, 0, humidity_texture[id.xy], 1);   
}


[numthreads(1, 1, 1)]
void GenerateBiomeColorTexture(uint3 id : SV_DispatchThreadID)
{
    float4 color;
    float height_value = height_texture[id.xy];

    if (has_ocean && height_value < 0)
    {
        float depth = clamp(-height_value, 0, 1);
        color = gradient_ocean_texture[uint2(heat_texture[id.xy] * width, depth * height)];
    }
    else
    {
        color = gradient_biome_texture[uint2(heat_texture[id.xy] * width, humidity_texture[id.xy] * height)];
    }
    color_texture_out[id.xy] = color;
}


[numthreads(1, 1, 1)]
void GenerateOceanColorTexture(uint3 id : SV_DispatchThreadID)
{
    float height_value = clamp(1 + height_texture[id.xy], 0, 1);
    color_texture_out[id.xy] = gradient_ocean_texture[uint2(heat_texture[id.xy] * width, height_value * height)];
}


[numthreads(1, 1, 1)]
void GenerateGroundColorTexture(uint3 id : SV_DispatchThreadID)
{
    color_texture_out[id.xy] = gradient_biome_texture[uint2(heat_texture[id.xy] * width, humidity_texture[id.xy] * height)];
}

